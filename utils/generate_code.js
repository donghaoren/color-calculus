const fs = require("fs");
const prettier = require("prettier");
const { allPairsShortestPaths } = require("./shortest_path");

const emittedLines = [];
const emittedLinesDTS = [];

// List files under src/transforms
const transformFiles = fs.readdirSync("./src/transforms");

// Collect the conversion functions into a graph
const edges = []; // Edges for A_to_B functions
const edges_d = []; // Edges for A_to_B_derivative functions
let nodes = new Set(); // Nodes, one for each colorspace

let tindex = 0;
for (const filename of transformFiles) {
  if (filename.endsWith(".js")) {
    const contents = fs.readFileSync("./src/transforms/" + filename, "utf-8");
    let imports = new Map();
    contents.replace(
      /^ *export +(function|const) +(([0-9a-zA-Z]+)_to_([0-9a-zA-Z]+)) *[(=]/gm,
      (m, _, mName, mFrom, mTo) => {
        imports.set(mName, "_I" + (tindex++).toString(16));
        nodes.add(mFrom);
        nodes.add(mTo);
        edges.push([mFrom, mTo, imports.get(mName)]);
      }
    );
    contents.replace(
      /^ *export +(function|const) +(([0-9a-zA-Z]+)_to_([0-9a-zA-Z]+)_derivative) *[(=]/gm,
      (m, _, mName, mFrom, mTo) => {
        imports.set(mName, "_I" + (tindex++).toString(16));
        nodes.add(mFrom);
        nodes.add(mTo);
        edges_d.push([
          mFrom,
          mTo,
          [imports.get(mName.replace("_derivative", "")), imports.get(mName)]
        ]);
      }
    );
    imports = Array.from(imports);
    if (imports.length > 0) {
      emittedLines.push(
        `import { ${imports
          .map(x => `${x[0]} as ${x[1]}`)
          .join(",")} } from "./transforms/${filename.replace(".js", "")}";`
      );
    }
  }
}

nodes = Array.from(nodes).sort();

const shortestPath = allPairsShortestPaths(nodes, edges);
const shortestPath_d = allPairsShortestPaths(nodes, edges_d);

const rArgs = index => `r${index}_1, r${index}_2, r${index}_3`;

for (let i = 0; i < nodes.length; i++) {
  for (let j = 0; j < nodes.length; j++) {
    if (i != j) {
      const path = shortestPath(i, j);
      const ni = nodes[i];
      const nj = nodes[j];
      if (!path) continue;
      emittedLines.push(
        `export const ${ni}_to_${nj} = compose([${path.join(",")}]);`
      );
      emittedLinesDTS.push(`
      /** Convert color from ${ni} to ${nj} */
      export function ${ni}_to_${nj}(c1: number, c2: number, c3: number): [number, number, number];
      export function ${ni}_to_${nj}(c: number[]): [number, number, number];
      `);
    }
  }
}

for (let i = 0; i < nodes.length; i++) {
  for (let j = 0; j < nodes.length; j++) {
    if (i != j) {
      const path = shortestPath_d(i, j);
      const ni = nodes[i];
      const nj = nodes[j];
      if (!path) continue;
      emittedLines.push(
        `export const ${ni}_to_${nj}_derivative = compose_derivative([${path
          .map(item => `[${item[0]},${item[1]}]`)
          .join(",")}]);`
      );
      emittedLinesDTS.push(`
      /** The derivative (Jacobian) for ${ni}_to_${nj} */
      export function ${ni}_to_${nj}_derivative(c1: number, c2: number, c3: number): number[][];
      export function ${ni}_to_${nj}_derivative(c: number[]): number[][];
      `);
    }
  }
}

fs.writeFileSync(
  "src/main.js",
  prettier.format(
    "// This file is automatically generated by utils/generate_code.js\n" +
      fs
        .readFileSync("src/main.template.js", "utf-8")
        .replace("// [GENERATED_CODE]", emittedLines.join("\n")),
    { parser: "babel" }
  )
);

fs.writeFileSync(
  "dist/color-calculus.d.ts",
  prettier.format(
    "// This file is automatically generated by utils/generate_code.js\n" +
      fs
        .readFileSync("src/main.template.d.ts", "utf-8")
        .replace("// [GENERATED_CODE]", emittedLinesDTS.join("\n")),
    { parser: "typescript" }
  )
);
